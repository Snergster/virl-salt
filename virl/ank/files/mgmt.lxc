#!/bin/bash

#
# lxc: linux Container library

# Authors:
# Daniel Lezcano <daniel.lezcano@free.fr>
# Modified for use by VIRL jumphost/gateways on 2014-12-02.
# The following license text pertains exclusively to this file.

# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.

# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.

# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

# Detect use under userns (unsupported)
for arg in "$@"; do
    [ "$arg" = "--" ] && break
    if [ "$arg" = "--mapped-uid" -o "$arg" = "--mapped-gid" ]; then
        echo "This template can't be used for unprivileged containers." 1>&2
        echo "You may want to try the \"download\" template instead." 1>&2
        exit 1
    fi
done

# Make sure the usual locations are in PATH
export PATH=$PATH:/usr/sbin:/usr/bin:/sbin:/bin

install_sshd()
{
    rootfs=$1

    tree="\
$rootfs/var/run/sshd \
$rootfs/var/empty/sshd \
$rootfs/var/lib/empty/sshd \
$rootfs/var/log \
$rootfs/etc/alternatives \
$rootfs/etc/init.d \
$rootfs/etc/rc.d \
$rootfs/etc/ssh \
$rootfs/etc/sysconfig/network-scripts \
$rootfs/etc/virl \
$rootfs/dev/shm \
$rootfs/run/shm \
$rootfs/proc \
$rootfs/sys \
$rootfs/bin \
$rootfs/sbin \
$rootfs/usr \
$rootfs/tmp \
$rootfs/home/ \
$rootfs/root \
$rootfs/lib \
$rootfs/lib64"

    mkdir -p $tree
    if [ $? -ne 0 ]; then
        return 1
    fi

    return 0
}

configure_sshd()
{
    rootfs=$1
    chmod 1777 $rootfs/tmp

    cp /etc/services $rootfs/etc
    cat <<EOF > $rootfs/etc/passwd
root:x:0:0:root:/root:/bin/bash
sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin
$username:x:$userid:$groupid:User generated by VIRL:/home/$username:/bin/bash
EOF

    cat <<EOF > $rootfs/etc/group
root:x:0:root
sshd:x:74:
$username:x:$groupid:
EOF

    cat <<EOF > $rootfs/etc/shadow
$username:$password:16360:0:99999:7:::
EOF
    chmod 0600 $rootfs/etc/shadow

    # by default setup root password with no password
    cat <<EOF > $rootfs/etc/ssh/sshd_config
Port ${node_port:-22}
Protocol 2
HostKey /etc/ssh/ssh_host_rsa_key
#HostKey /etc/ssh/ssh_host_dsa_key
UsePrivilegeSeparation yes
KeyRegenerationInterval 3600
ServerKeyBits 768
SyslogFacility AUTH
LogLevel INFO
LoginGraceTime 120
PermitRootLogin no
StrictModes yes
RSAAuthentication yes
PubkeyAuthentication yes
IgnoreRhosts yes
RhostsRSAAuthentication no
HostbasedAuthentication no
PermitEmptyPasswords yes
ChallengeResponseAuthentication no
UseDNS no
MaxSessions 60
PasswordAuthentication yes
EOF

    user_path="$rootfs/home/$username"
    if [ -n "$auth_key" -a -f "$auth_key" ]; then
        ssh_path="$user_path/.ssh"
        mkdir -p $ssh_path
        cp $auth_key "$ssh_path/authorized_keys"
        chmod 700 "$ssh_path"
        echo "Inserted SSH public key from $auth_key into $ssh_path"
        cat <<EOF > /config
UserKnownHostsFile=/dev/null
StrictHostKeyChecking=no
EOF
        echo "Disabled host key checking for user"
    fi

    key_path="$rootfs/etc/ssh/ssh_host_rsa_key"
    if [ -n "$host_key" -a -f "$host_key" ]; then
        cp "$host_key" "$key_path"
        chmod 600 "$key_path"
        ssh-keygen -y -f "$key_path" > "$key_path.pub"
    else
        ssh-keygen -t rsa -N "" -f "$key_path"
        #ssh-keygen -t dsa -N "" -f $rootfs/etc/ssh/ssh_host_dsa_key
    fi

    if [ -n "$virl_data" -a -f "$virl_data" ]; then
        cp "$virl_data" "$rootfs/etc/virl/virl.cfg"
        
    fi

    cat <<EOF >> $rootfs/home/$username/.bash_profile
PS1="\u@\h$ "
EOF

    if [ -n "$etc_hosts" -a -f "$etc_hosts" ]; then
        cp "$etc_hosts" $rootfs/etc/hosts
    fi

    if [ -z "$hostname" ]; then
        hostname=mgmt
    fi
    echo "$hostname" > $rootfs/etc/hostname

    chown -R $userid:$groupid "$user_path"
    return 0
}

configure_rsyslogd() {
    rootfs=$1
    cat <<EOF >$rootfs/etc/rsyslogd.conf
# Default Settings

# Load Modules
module(load="imudp")
module(load="imtcp")
module(load="omfwd")
module(load="imuxsock")

# rsyslog Templates

# rsyslog Input Modules
input(type="imudp"
         port=""
         ruleset="forwardudp")
input(type="imtcp"
         port=""
         ruleset="forwardtcp")

# rsyslog RuleSets
ruleset(name="forwardudp") {
        action(type="omfwd"
                Target="127.0.0.1"
                Port="1514"
                Protocol="udp")

}

ruleset(name="forwardtcp") {
        action(type="omfwd"
                Target="127.0.0.1"
                Port="1514"
                Protocol="tcp")

}
EOF
}

copy_configuration()
{
    path=$1
    rootfs=$2
    name=$3
    template_path=$4

    grep -q "^lxc.rootfs" $path/config 2>/dev/null || echo "lxc.rootfs = $rootfs" >> $path/config
cat <<EOF >> $path/config
lxc.pts = 1024
lxc.kmsg = 0
lxc.cap.drop = sys_module mac_admin mac_override sys_time

# When using LXC with apparmor, uncomment the next line to run unconfined:
#lxc.aa_profile = unconfined

lxc.mount.entry = /dev dev none ro,bind 0 0
lxc.mount.entry = /lib lib none ro,bind 0 0
lxc.mount.entry = /bin bin none ro,bind 0 0
lxc.mount.entry = /usr usr none ro,bind 0 0
lxc.mount.entry = /sbin sbin none ro,bind 0 0
lxc.mount.entry = tmpfs var/run/sshd tmpfs mode=0644 0 0
lxc.mount.entry = $template_path sbin/init none ro,bind 0 0
lxc.mount.entry = proc proc proc nodev,noexec,nosuid 0 0
lxc.mount.entry = sysfs sys sysfs ro 0 0
lxc.mount.entry = /etc/init.d etc/init.d none ro,bind 0 0
lxc.mount.entry = /etc/alternatives etc/alternatives none ro,bind 0 0
EOF

    # Oracle Linux and Fedora need the following two bind mounted
    if [ -d /etc/sysconfig/network-scripts ]; then
        cat <<EOF >> $path/config
lxc.mount.entry = /etc/sysconfig/network-scripts etc/sysconfig/network-scripts none ro,bind 0 0
EOF
    fi

    if [ -d /etc/rc.d ]; then
        cat <<EOF >> $path/config
lxc.mount.entry = /etc/rc.d etc/rc.d none ro,bind 0 0
EOF
    fi

    # if no .ipv4 section in config for eth0, then have the container run dhcp
    #ipv4=`grep -c "^lxc.network.ipv4[^.]" $path/config`
    #if [ "$ipv4" != 2]; then
    #    touch $rootfs/run-dhcp
    #fi

    if [ "$(uname -m)" = "x86_64" ]; then
        cat <<EOF >> $path/config
lxc.mount.entry = /lib64 lib64 none ro,bind 0 0
EOF
    fi

    # setup sysctl config
    cat <<EOF >> /etc/sysctl.conf
net.ipv6.conf.default.autoconf = 0
net.ipv6.conf.all.autoconf = 0
EOF

}

usage()
{
    cat <<EOF
$1 -h|--help -p|--path=<path> [--rootfs=<path>]
EOF
    return 0
}

check_for_cmd()
{
    cmd_path=`type $1`
    if [ $? -ne 0 ]; then
        echo "The command '$1' $cmd_path is not accessible on the system"
        exit 1
    fi
    # we use cut instead of awk because awk is alternatives symlink on ubuntu
    # and /etc/alternatives isn't bind mounted
    cmd_path=`echo $cmd_path |cut -d ' ' -f 3`
}

long_opts="help,rootfs:,path:,name:,auth-key:,host-key:,hostname:,username:,userid:"
long_opts="$long_opts,groupid:,password:,virl-data:,node-port:,etc-hosts:"
options=$(getopt -o hp:n:S:R:N:U:I:G:P:V:H:L: -l $long_opts  -- "$@")
if [ $? -ne 0 ]; then
        usage $(basename $0)
    exit 1
fi
eval set -- "$options"

while true
do
    case "$1" in
        -h|--help)      usage $0 && exit 0;;
        -p|--path)      path=$2; shift 2;;
        --rootfs)       rootfs=$2; shift 2;;
        -n|--name)      name=$2; shift 2;;
        -S|--auth-key)  auth_key=$2; shift 2;;
        -R|--host-key)  host_key=$2; shift 2;;
        -N|--hostname)  hostname=$2; shift 2;;
        -U|--username)  username=$2; shift 2;;
        -I|--userid)    userid=$2; shift 2;;
        -G|--groupid)   groupid=$2; shift 2;;
        -P|--password)  password=$2; shift 2;;
        -V|--virl-data) virl_data=$2; shift 2;;
        -H|--etc-hosts) etc_hosts=$2; shift 2;;
        -L|--node-port) node_port=$2; shift 2;;
        --)             shift 1; break ;;
        *)              break ;;
    esac
done

if [ "$(id -u)" != "0" ]; then
    echo "This script should be run as 'root'"
    exit 1
fi

if [ $0 = "/sbin/init" ]; then

    PATH="$PATH:/bin:/sbin:/usr/sbin:/usr/bin"
    check_for_cmd /usr/sbin/init.lxc
    check_for_cmd sshd
    sshd_path=$cmd_path

    # run dhcp?
    #if [ -f /run-dhcp ]; then
    # no
    if false; then
        check_for_cmd dhclient
        check_for_cmd ifconfig
        touch /etc/fstab
        rm -f /dhclient.conf
        cat > /dhclient.conf << EOF
send host-name "<hostname>";
EOF
        ifconfig eth0 up
        dhclient eth0 -cf /dhclient.conf
        echo "Container IP address:"
        ifconfig eth0 |grep inet
    fi

    if type -P sysctl ; then
        sysctl -p
    fi
    if type -P ethtool ; then
        ls -1 /sys/class/net | grep eth | while read ifname ; do
            ethtool -K  tx off
        done
    fi
    if type -P rsyslogd ; then
        rsyslogd -f /etc/rsyslogd.conf &
    fi
    if type -P virl_collection_client ; then
        virl_collection_client &
    fi
    if type -P virl-telnet-websocket ; then
        virl-telnet-websocket &
    fi
    exec /usr/sbin/init.lxc -- $sshd_path
    exit 1
fi

if [ -z "$path" ]; then
    echo "'path' parameter is required"
    exit 1
fi

# detect rootfs
config="$path/config"
if [ -z "$rootfs" ]; then
    if grep -q '^lxc.rootfs' $config 2>/dev/null ; then
        rootfs=$(awk -F= '/^lxc.rootfs =/{ print $2 }' $config)
    else
        rootfs=$path/rootfs
    fi
fi

if [ -z "$username" ]; then
    echo "Username is missing"
fi

if [ -z "$userid" ]; then
    echo "Userid is missing"
fi

if [ -z "$groupid" ]; then
    echo "Groupid is missing"
fi

if [ -z "$password" ]; then
    echo "Password (shadow) is missing"
fi

install_sshd $rootfs
if [ $? -ne 0 ]; then
    echo "failed to install sshd's rootfs"
    exit 1
fi

configure_sshd $rootfs
if [ $? -ne 0 ]; then
    echo "failed to configure sshd template"
    exit 1
fi

configure_rsyslogd $rootfs
if [ $? -ne 0 ]; then
    echo "failed to configure rsyslogd template"
    exit 1
fi

copy_configuration $path $rootfs $name $0
if [ $? -ne 0 ]; then
    echo "failed to write configuration file"
    exit 1
fi
